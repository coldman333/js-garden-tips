<!DOCTYPE HTML>
<html>
<head>
    <title>js Garden tips</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript" charset="utf-8" src="js/jquery-1.6.4.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/phonegap-1.1.0.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/jquery.mobile-1.0rc1.js"></script>
    <link rel="stylesheet" href="js/jquery.mobile-1.0rc1.css"/>
    <link rel="stylesheet" href="js/style.css"/>

</head>
<body>


<!-- Start of first page: #one -->
<div data-role="page" id="foo">


    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->


    <div data-role="content" id="one">


     <ul  data-role="collapsible-set" data-theme="a">
        <li class="nav_intro" data-role="collapsible">
            <h1>Вступление</h1>
            <ul data-role="listview">
                <li><a href="#intro">Вступление</a></li>
            </ul>
        </li>
        <li class="nav_object" data-role="collapsible">
            <h1>Объекты</h1>
            <ul data-role="listview" >
                <li><a href="#object.general1">Объекты и их свойства</a></li>
                <li><a href="#object.prototype">Великий Прототип</a></li>
                <li><a href="#object.hasownproperty">Функция <code>hasOwnProperty</code></a></li>
                <li><a href="#object.forinloop">Цикл <code>for in</code></a></li>
            </ul>
        </li>
        <li class="nav_function" data-role="collapsible">
            <h1>Функции</h1>
            <ul data-role="listview" >
                <li><a href="#function.general">Выражения и объявление функций</a></li>
                <li><a href="#function.this">Как работает <code>this</code></a></li>
                <li><a href="#function.closures">Замыкания и ссылки</a></li>
                <li><a href="#function.arguments">Объект <code>arguments</code></a></li>
                <li><a href="#function.constructors">Конструктор</a></li>
                <li><a href="#function.scopes">Области видимости и пространства имён</a></li>
            </ul>
        </li>
        <li class="nav_array" data-role="collapsible">
            <h1>Массивы</h1>
            <ul data-role="listview" >
                <li><a href="#array.general">﻿﻿ Итерации по массивам и свойства</a></li>
                <li><a href="#array.constructor">Конструктор <code>Array</code></a></li>
            </ul>
        </li>
        <li class="nav_types" data-role="collapsible">
            <h1>Типы</h1>
            <ul data-role="listview" >
                <li><a href="#types.equality">﻿ Равенство и сравнение</a></li>
                <li><a href="#types.typeof">Оператор <code>typeof</code></a></li>
                <li><a href="#types.instanceof">Оператор <code>instanceof</code></a></li>
                <li><a href="#types.casting">Приведение типов</a></li>
            </ul>
        </li>
        <li class="nav_core" data-role="collapsible">
            <h1>Нативности</h1>
            <ul data-role="listview" >
                <li><a href="#core.eval">Почему нельзя использовать <code>eval</code></a></li>
                <li><a href="#core.undefined"><code>undefined</code> и <code>null</code></a></li>
                <li><a href="#core.semicolon">Автоматическая вставка точек с запятой</a></li>
            </ul>
        </li>
        <li class="nav_other" data-role="collapsible">
            <h1>Другое</h1>
            <ul data-role="listview" >
                <li><a href="#other.timeouts"><code>setTimeout</code> и <code>setInterval</code></a></li>
            </ul>
        </li>
        <li class="nav_appendix" data-role="collapsible">
            <h1>Пояснения</h1>
            <ul data-role="listview" >
                <li><a href="#appendix.fromtranslators">От переводчиков</a></li>
            </ul >
        </li>
    </ul>


   </div>
    <!-- /content -->

    <div data-role="footer" data-theme="a">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page one -->

<!-- Start of second page: #intro -->

<div data-role="page" id="intro" data-theme="a">

   <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
   </div>
 <!-- /header -->

   <div data-role="content" data-theme="b">

       <article>
        <h1>Вступление</h1>

        <div><p><strong>JavaScript Гарден</strong> это постоянно обновляющаяся и растущая документация по самым
            заковыристым темам языка JavaScript. В ней вы найдёте советы о том, как избежать распространённых ошибок и
            предсказать появление тех или иных багов. В документации подробно освещены проблемы оптимизации и
            нерекомендуемые практики с которыми, продираясь к глубинам языка, могут столкнуться даже просвещённые
            JavaScript-программисты.</p>

            <p>JavaScript Гарден <strong>не</strong> имеет цели научить вас языку JavaScript. Вам понадобится реальный
                опыт работы с языком чтобы понимать темы, рассматриваемые в этом руководстве. Если вам требуется изучить
                основы языка, пожалуйста внимательно ознакомьтесь с замечательным <a
                        href="https://developer.mozilla.org/en/JavaScript/Guide">руководством</a> на сайте Mozilla
                Developer Network.</p></div>

    <!-- Articles-->
    <h2>Авторы</h2>

        <div><p>Это руководство является результатом работы двух заядлых пользователей Stack Overflow: <a
                href="http://stackoverflow.com/users/170224/ivo-wetzel">Иво Ветцель /Ivo Wetzel/</a> (автора текста) и
            <a href="http://stackoverflow.com/users/313758/yi-jiang">Чжан И Цзян /Zhang Yi Jiang/</a> (дизайнера).</p>
        </div>

    <h2>Участники</h2>

        <div>
            <ul>
                <li><a href="https://github.com/caio">Кайо Ромао /Caio Romão/</a> (проверка орфографии)</li>
                <li><a href="https://github.com/blixt">Андреас Бликст /Andreas Blixt/</a> (проверка грамматики)</li>
            </ul>
        </div>

    <h2>Переводчики</h2>
        <div>
            <ul>
                <li><a href="http://shamansir.madfire.net/">&#39;shaman.sir&#39;</a></li>
                <li><a href="http://anton.shevchuk.name/">Антон Шевчук</a></li>
                <li><a href="http://nixsolutions.com/">Максим Лозовой</a></li>
                <li><a href="http://nixsolutions.com/">Елена Пашкова</a></li>
            </ul>
        </div>
    <h2>Лицензия</h2>

        <div><p>JavaScript Гарден распространяется под <a
                href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">лицензией MIT</a> и
            располагается на <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. Если вы найдёте ошибку
            или опечатку, пожалуйста <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">сообщите нам о
                ней</a> или запросите права на загрузку в репозиторий. Кроме того, вы можете найти нас в <a
                    href="http://chat.stackoverflow.com/rooms/17/javascript">комнате JavaScript</a> среди чатов Stack
            Overflow.</p></div>
    </article>
    </div>
    <!-- /content -->
    <div data-role="footer">
         <div class="ui-grid-b">
            <div class="ui-block-a"> </div>
            <div class="ui-block-b"> </div>
            <div class="ui-block-c"><a data-role="button" data-icon="arrow-r" data-iconpos="right" href="#object.general1"> вперед </a></div>
        </div><!-- /grid-b -->
    </div>
    <!-- /intro -->
</div>


<!-- Start of second page: #object -->
<div data-role="page" id="object.general1" data-theme="a">
    <div data-role="header" data-theme="a">
        <h1>Объекты </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->

    <div data-role="content" data-theme="b">
         <article>

            <h2>Объекты и их свойства</h2>

            <div><p>В JavaScript всё является объектом, лишь за двумя исключениями — <a
                    href="#core.undefined"><code>null</code></a> и <a href="#core.undefined"><code>undefined</code></a>.</p>

            <pre><code>false.toString() // &#39;false&#39;
                [1, 2, 3].toString(); // &#39;1,2,3&#39;

                function Foo(){}
                Foo.bar = 1;
                Foo.bar; // 1
            </code></pre>

                <p>Неверно считать, что числовые литералы нельзя использовать в качестве объектов — это распространённое
                    заблуждение. Его причиной является упущение в парсере JavaScript, благодаря которому применение <em>точечной
                        нотации</em> к числу воспринимается им как литерал числа с плавающей точкой.</p>

            <pre><code>2.toString(); // вызывает SyntaxError
            </code></pre>

                <p>Есть несколько способов обойти этот недостаток и любой из них можно использовать для того, чтобы работать
                    с числами, как с объектами:</p>

            <pre><code>2..toString(); // вторая точка распознаётся корректно
                 2 .toString(); // обратите внимание на пробел перед точкой
                (2).toString(); // двойка вычисляется заранее
            </code></pre>

            </div>
            <div>

                <h3>Объекты как тип данных</h3>

                <p>Объекты в JavaScript могут использоваться как <a
                        href="http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0"><em>хеш-таблицы</em></a>:
                    подавляющей частью состоят из именованных свойств (ключей), привязанных к значениям.</p>

                <p>Используя объектный литерал — нотацию <code>{}</code> — можно создать простой объект. Новый объект <a
                        href="#object.prototype">наследуется</a> от <code>Object.prototype</code> и не имеет <a
                        href="#object.hasownproperty">собственных свойств</a>.</p>

            <pre><code>var foo = {}; // новый пустой объект

                // новый объект со свойством &#39;test&#39;, имеющим значение 12
                var bar = {test: 12};
            </code></pre>

            </div>
            <div><h3>Доступ к свойствам</h3>

                <p>Получить доступ к свойствам объекта можно двумя способами: используя либо точечную нотацию, либо запись
                    квадратными скобками.</p>

            <pre><code>var foo = {name: &#39;Kitten&#39;}
                foo.name; // kitten
                foo[&#39;name&#39;]; // kitten

                var get = &#39;name&#39;;
                foo[get]; // kitten

                foo.1234; // SyntaxError
                foo[&#39;1234&#39;]; // работает
            </code></pre>

                <p>Обе нотации идентичны по принципу работы — одна лишь разница в том, что использование квадратных скобок
                    позволяет устанавливать свойства динамически и использовать такие имена свойств, какие в других случаях
                    могли бы привести к синтаксической ошибке.</p>

            </div>
            <div><h3>Удаление свойств</h3>

                <p>Единственный способ удалить свойство у объекта — использовать оператор <code>delete</code>; устанавливая
                    свойство в <code>undefined</code> или <code>null</code>, вы только заменяете связанное с ним <em>значение</em>,
                    но не удаляете <em>ключ</em>.</p>

                <aside>
                    <p><strong>Замечание</strong> от перев.: Если ссылок на значение больше нет, то сборщиком мусора
                        удаляется и само значение, но ключ объекта при этом всё так же имеет новое значение.</p>
                </aside>

            <pre><code>var obj = {
                bar: 1,
                foo: 2,
                baz: 3
                };
                obj.bar = undefined;
                obj.foo = null;
                delete obj.baz;

                for(var i in obj) {
                if (obj.hasOwnProperty(i)) {
                console.log(i, &#39;&#39; + obj[i]);
                }
                }
            </code></pre>

                <p>Приведённый код выведет две строки: <code>bar undefined</code> и <code>foo null</code> — на самом деле
                    удалено было только свойство <code>baz</code> и посему только оно будет отсутствовать в выводе.</p>

            </div>
            <div><h3>Запись ключей</h3>

            <pre><code>var test = {
                &#39;case&#39;: &#39;Я — ключевое слово, поэтому меня надо записывать строкой&#39;,
                delete: &#39;Я тоже ключевое слово, так что я&#39; // бросаю SyntaxError
                };
            </code></pre>

                <p>Свойства объектов могут записываться как явно символами, так и в виде закавыченных строк. В связи с
                    другим упущением в парсере JavaScript, этот код выбросит <code>SyntaxError</code> во всех версиях ранее
                    ECMAScript 5.</p>

                <p>Источником ошибки является факт, что <code>delete</code> — это <em>ключевое слово</em> и поэтому его
                    необходимо записывать как <em>строчный литерал</em>: ради уверенности в том, что оно будет корректно
                    опознано более старыми движками JavaScript.</p>

                <p><em>От перев.:</em> И еще один пример в пользу строковой нотации, это относится к <a
                        href="http://ru.wikipedia.org/wiki/JSON">JSON</a>:</p>

            <pre><code>// валидный JavaScript и валидный JSON
                {
                &#39;foo&#39;: &#39;oof&#39;,
                &#39;bar&#39;: &#39;rab&#39;
                }

                // валидный JavaScript и НЕ валидный JSON
                {
                foo: &#39;oof&#39;,
                bar: &#39;rab&#39;
                }
            </code></pre>
            </div>
         </article>
    </div>
    <!-- /content -->

    <div data-role="footer">
        <div class="ui-grid-b">
            <div class="ui-block-a"> <a data-role="button" data-icon="arrow-l" href="#intro"> назад </a></div>
            <div class="ui-block-b"> </div>
            <div class="ui-block-c"><a data-role="button" data-icon="arrow-r" data-iconpos="right" href="#object.prototype"> вперед </a></div>
        </div><!-- /grid-b -->
    </div>
    <!-- /footer -->
</div>
<!-- /page  -->


<!-- Start of second page: #3 Объекты Великий Прототип-->
<div data-role="page" id="object.prototype" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>Объекты</h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


        <article><h2>Великий Прототип</h2>

            <div><p>В JavaScript отсутствует классическая модель наследования — вместо неё используется <a
                    href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><em>прототипная
                модель</em></a>.</p>

                <p>Хотя её часто расценивают как один из недостатков JavaScript, на самом деле прототипная модель
                    наследования намного мощнее классической. К примеру, поверх неё можно предельно легко реализовать
                    классическое наследование, а попытки совершить обратное вынудят вас попотеть.</p>

                <p>Из-за того, что JavaScript — практически единственный широко используемый язык с прототипным
                    наследованием, придётся потратить некоторое время на осознание различий между этими двумя
                    моделями.</p>

                <p>Первое важное отличие заключается в том, что наследование в JavaScript выполняется с использованием
                    так называемых <em>цепочек прототипов</em>.</p>

                <aside>
                    <p><strong>Замечание:</strong> В результате выполнения конструкции <code>Bar.prototype =
                        Foo.prototype</code> оба объекта будут делить друг с другом <strong>один и тот же</strong>
                        прототип. Так что изменение прототипа одного из объектов повлечёт за собой изменение прототипа
                        другого и наоборот — вряд ли это окажется тем, чего вы ожидали.</p>
                </aside>

<pre><code>function Foo() {
    this.value = 42;
    }
    Foo.prototype = {
    method: function() {}
    };

    function Bar() {}

    // Установим значением прототипа Bar новый экземпляр Foo
    Bar.prototype = new Foo();
    Bar.prototype.foo = &#39;Hello World&#39;;

    // Убедимся, что Bar является действующим конструктором
    Bar.prototype.constructor = Bar;

    var test = new Bar() // создадим новый экземпляр bar

    // Цепочка прототипов, которая получится в результате
    test [instance of Bar]
    Bar.prototype [instance of Foo]
    { foo: &#39;Hello World&#39; }
    Foo.prototype
    { method: ... }
    Object.prototype
    { toString: ... /* и т.д. */ }
</code></pre>

                <p>В приведённом коде объект <code>test</code> наследует оба прототипа: <code>Bar.prototype</code> и
                    <code>Foo.prototype</code>; следовательно, он имеет доступ к функции <code>method</code> которую мы
                    определили в прототипе <code>Foo</code>. Также у него есть доступ к свойству <code>value</code>
                    <strong>одного уникального</strong> экземпляра <code>Foo</code>, который является его протипом.
                    Важно заметить, что код <code>new Bar()</code> <strong>не</strong> создаёт новый экземпляр
                    <code>Foo</code>, а повторно вызывает функцию, которая была назначен его прототипом: таким образом
                    все новые экземпляры <code>Bar</code> будут иметь <strong>одинаковое</strong> свойство
                    <code>value</code>.</p>

                <aside>
                    <p><strong>Замечание:</strong> Никогда <strong>не</strong> используйте конструкцию <code>Bar.prototype
                        = Foo</code>, поскольку ссылка будет указывать не на прототип <code>Foo</code>, а на объект
                        функции <code>Foo</code>. Из-за этого цепочка прототипов будет проходить через <code>Function.prototype</code>,
                        а не через <code>Foo.prototype</code> и в результате функция <code>method</code> не будет
                        содержаться в цепочке прототипов.</p>
                </aside>

            </div>
            <div><h3>Поиск свойств</h3>

                <p>При обращении к какому-либо свойству объекта, JavaScript проходит <strong>вверх</strong> по цепочке
                    прототипов этого объекта, пока не найдет свойство c запрашиваемым именем.</p>

                <p>Если он достигнет верхушки этой цепочки (<code>Object.prototype</code>) и при этом так и не найдёт
                    указанное свойство, вместо него вернётся значение <a href="#core.undefined">undefined</a>.</p>

            </div>
            <div><h3>Свойство <code>prototype</code></h3>

                <p>То, что свойство <code>prototype</code> используется языком для построения цепочек прототипов, даёт
                    нам возможность присвоить <strong>любое</strong> значение этому свойству. Однако обычные примитивы,
                    если назначать их в качестве прототипа, будут просто-напросто игнорироваться.</p>

<pre><code>function Foo() {}
    Foo.prototype = 1; // ничего не произойдёт
    Foo.prototype = {
    "foo":"bar"
    };
</code></pre>

                <p>При этом присвоение объектов, как в примере выше, позволит вам динамически создавать цепочки
                    прототипов.</p>

            </div>
            <div><h3>Производительность</h3>

                <p>Поиск свойств, располагающихся относительно высоко по цепочке прототипов, может негативно сказаться
                    на производительности, особенно в критических местах кода. Если же мы попытаемся найти
                    несуществующее свойство, то поиск будет осуществлён вообще по всей цепочке, со всеми вытекающими
                    последствиями.</p>

                <p>Вдобавок, при <a href="#object.forinloop">циклическом переборе</a> свойств объекта, будет обработано
                    <strong>каждое</strong> свойство, существующее в цепочке прототипов.</p>

            </div>
            <div><h3>Расширение встроенных прототипов</h3>

                <p>Часто встречается неверное применение прототипов — расширение прототипа <code>Object.prototype</code>
                    или прототипов одного из встроенных объектов JavaScript.</p>

                <p>Подобная практика нарушает принцип <em>инкапсуляции</em>, и имеет соответствующее название — <a
                        href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>. К сожалению, в основу
                    многих широко распространенных фреймворков, например Prototype, положен принцип изменения базовых
                    прототипов. Вам же стоит запомнить — от хорошей жизни прототипы встроенных объектов не меняют.</p>

                <p><strong>Единственным</strong> оправданием для расширения встроенных прототипов может быть только
                    воссоздание возможностей более новых движков JavaScript, например функции <a
                            href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>,
                    которая появилась в версии 1.6.</p>

            </div>
            <div><h3>Заключение</h3>

                <p>Перед тем, как вы приступите к разработке сложных приложений на JavaScript, вы
                    <strong>должны</strong> полностью осознать как работают прототипы, и как организовывать наследование
                    на их основе. Также, помните о зависимости между длиной цепочек прототипов и производительностью —
                    разрывайте их при необходимости. Кроме того — <strong>никогда</strong> не расширяйте прототипы
                    встроенных объектов (ну, если только для совместимости с новыми возможностями Javascript).</p></div>
        </article>


    </div>
    <!-- /content -->

    <div data-role="footer">
         <div class="ui-grid-b">
            <div class="ui-block-a"> <a data-role="button" data-icon="arrow-l" href="#object.general1"> назад </a></div>
            <div class="ui-block-b"> </div>
            <div class="ui-block-c"><a data-role="button" data-icon="arrow-r" data-iconpos="right" href="#object.hasownproperty"> вперед </a></div>
        </div><!-- /grid-b -->
    </div>
    <!-- /footer -->
</div>
<!-- /page  -->


<!-- Start of second page: #4 Объекты Функция-->
<div data-role="page" id="object.hasownproperty" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>Объекты </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">

        <article><h2>Функция <code>hasOwnProperty</code></h2>

            <div><p>Если вам необходимо проверить, определено ли свойство у <em>самого объекта</em>, а
                <strong>не</strong> в его <a href="#object.prototype">цепочке прототипов</a>, вы можете использовать
                метод <code>hasOwnProperty</code>, который все объекты наследуют от <code>Object.prototype</code>.</p>

                <aside>
                    <p><strong>Примечание:</strong> Для проверки наличия свойства <strong>недостаточно</strong>
                        проверять, эквивалентно ли оно <code>undefined</code>. Свойство может вполне себе существовать,
                        но при этом ему может быть присвоено значение <code>undefined</code>.</p>
                </aside>

                <p><code>hasOwnProperty</code> — единственная функция в JavaScript, которая позволяет получить свойства
                    объекта <strong>без обращения</strong> к цепочке его прототипов.</p>

<pre><code>// испортим Object.prototype
    Object.prototype.bar = 1;
    var foo = {goo: undefined};

    foo.bar; // 1
    &#39;bar&#39; in foo; // true

    foo.hasOwnProperty(&#39;bar&#39;); // false
    foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

                <p>Только используя `hasOwnProperty` можно гарантировать правильный результат при переборе свойств
                    объекта. И <strong>нет</strong> иного способа для определения свойств, которые определены в <em>самом</em>
                    объекте, а не где-то в цепочке его прототипов.</p>

            </div>
            <div><h3><code>hasOwnProperty</code> как свойство</h3>

                <p>JavaScript <strong>не</strong> резервирует свойство с именем <code>hasOwnProperty</code>. Так что,
                    если есть потенциальная возможность, что объект может содержать свойство с таким именем, требуется
                    использовать <em>внешний</em> вариант функции <code>hasOwnProperty</code> чтобы получить корректные
                    результаты.</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
    return false;
    },
    bar: &#39;Да прилетят драконы&#39;
    };

    foo.hasOwnProperty(&#39;bar&#39;); // всегда возвращает false

    // Используем метод hasOwnProperty пустого объекта
    // и передаём foo в качестве this
    ({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true
</code></pre>

            </div>
            <div><h3>Заключение</h3>

                <p><strong>Единственным</strong> способом проверить существование свойства у объекта является
                    использование метода <code>hasOwnProperty</code>. При этом, рекомендуется использовать этот метод в
                    <strong>каждом</strong> <a href="#object.forinloop">цикле <code>for in</code></a> вашего проекта,
                    чтобы избежать возможных ошибок с ошибочным заимствованием свойств из <a href="#object.prototype">прототипов</a>
                    родительских объектов. Также вы можете использовать конструкцию
                    <code>{}.hasOwnProperty.call(...)</code> на случай, если кто-то вздумает расширить <a
                            href="#object.prototype">прототипы</a> встроенных объектов.</p></div>
        </article>


    </div>
    <!-- /content -->

    <div data-role="footer">
        <div class="ui-grid-b">
            <div class="ui-block-a"> <a data-role="button" data-icon="arrow-l" href="#object.prototype"> назад </a></div>
            <div class="ui-block-b"> </div>
            <div class="ui-block-c"><a data-role="button" data-icon="arrow-r" data-iconpos="right" href="#object.forinloo"> вперед </a></div>
        </div><!-- /grid-b -->
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #Объекты Цикл for in-->
<div data-role="page" id="object.forinloo" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>Объекты </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">
    <article >
         <h2>Цикл <code>for in</code></h2>

    <div><p>Как и оператор <code>in</code>, цикл <code>for in</code> проходит по всей цепочке прототипов обходя свойства
        объекта.</p>

        <aside>
            <p><strong>Примечание:</strong> Цикл <code>for in</code> <strong>не</strong> обходит те свойства объекта, у
                которых атрибут <code>enumerable</code> установлен в <code>false</code>; как пример - свойство <code>length</code>
                у массивов</p>
        </aside>

<pre><code>// Испортим Object.prototype
    Object.prototype.bar = 1;

    var foo = {moo: 2};
    for(var i in foo) {
    console.log(i); // печатает и bar и moo
    }
</code></pre>

        <p>Так как изменить поведение цикла <code>for in</code> как такового не представляется возможным, то для
            фильтрации нежелательных свойств объекта внутри этого цикла используют метод <a
                    href="#object.hasownproperty"><code>hasOwnProperty</code></a> из <code>Object.prototype</code>.</p>

        <aside>
            <p><strong>Примечание:</strong> Цикл <code>for in</code> всегда обходит всю цепочку прототипов полностью:
                таким образом, чем больше прототипов (слоёв наследования) в цепочке, тем медленнее работает цикл.</p>
        </aside>

    </div>
    <div><h3>Использование <code>hasOwnProperty</code> в качестве фильтра</h3>

<pre><code>// возьмём foo из примера выше
    for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
    console.log(i);
    }
    }
</code></pre>

        <p>Это единственная версия правильного использования цикла. Благодаря использованию <code>hasOwnPropery</code>
            будет выведено <strong>только</strong> свойство <code>moo</code>. Если же убрать <code>hasOwnProperty</code>,
            код становится нестабилен и могут возникнуть ошибки, особенно если кто-то изменил встроенные прототипы,
            такие как <code>Object.prototype</code>.</p>

        <p>Один из самых популярных фреймворков <a href="http://www.prototypejs.org/">Prototype</a> как раз этим и
            славится, и если вы его подключаете, то не забудьте использовать <code>hasOwnProperty</code> внутри цикла
            <code>for in</code>, иначе у вас гарантированно возникнут проблемы.</p>

    </div>
    <div><h3>Рекомендации</h3>

        <p>Рекомендация одна — <strong>всегда</strong> используйте <code>hasOwnProperty</code>. Пишите код, который
            будет в наименьшей мере зависеть от окружения, в котором он будет запущен — не стоит гадать, расширял кто-то
            прототипы или нет и используется ли в ней та или иная библиотека.</p></div>
</article>

    </div>
    <!-- /content -->

    <div data-role="footer">
       <div class="ui-grid-b">
            <div class="ui-block-a"> <a data-role="button" data-icon="arrow-l" href="#object.hasownproperty"> назад </a></div>
            <div class="ui-block-b"> </div>
            <div class="ui-block-c"><a data-role="button" data-icon="arrow-r" data-iconpos="right" href="#function.general"> вперед </a></div>
        </div><!-- /grid-b -->
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #two -->
<div data-role="page" id="function.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>Функций </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


      <article >
          <h2>Выражения и объявление функций</h2>

    <div><p>Функции в JavaScript тоже являются объектами (шок, сенсация) — следовательно, их можно передавать и
        присваивать точно так же, как и любой другой объект. Одним из вариантов использования такой возможности является
        передача <em>анонимной функции</em> как функции обратного вызова в другую функцию — к примеру, для асинхронных
        вызовов.</p>

    </div>
    <div><h3>Объявление <code>function</code></h3>

<pre><code>// всё просто и привычно
    function foo() {}
</code></pre>

        <p>В следующем примере описанная функция <a href="#function.scopes">резервируется</a> перед запуском всего
            скрипта; за счёт этого она доступна <em>в любом месте</em> кода, вне зависимости от того где она <em>определена</em>
            — даже если функция вызывается до её фактического объявления в коде.</p>

<pre><code>foo(); // сработает, т.к. функция будет создана до выполнения кода
    function foo() {}
</code></pre>

    </div>
    <div><h3><code>function</code> как выражение</h3>

<pre><code>var foo = function() {};
</code></pre>

        <p>В этом примере безымянная и <em>анонимная</em> функция присваивается переменной <code>foo</code>.</p>

<pre><code>foo; // &#39;undefined&#39;
    foo(); // вызовет TypeError
    var foo = function() {};
</code></pre>

        <p>Так как в данном примере выражение <code>var</code> — это определение функции, переменная с именем
            <code>foo</code> будет заранее зарезервирована перед запуском скрипта (таким образом, <code>foo</code> уже
            будет определена во время его работы).</p>

        <p>Но поскольку присвоения исполняются непосредственно во время работы кода, <code>foo</code> по умолчанию будет
            присвоено значение <a href="#core.undefined"><code>undefined</code></a> (до обработки строки с определением
            функции):</p>

<pre><code>var foo; // переменная неявно резервируется
    foo; // &#39;undefined&#39;
    foo(); // вызовет TypeError
    foo = function() {};
</code></pre>

    </div>
    <div><h3>Выражения с именованными фунциями</h3>

        <p>Существует еще ньюанс, касающийся именованных функций создающихся через присваивание:</p>

<pre><code>var foo = function bar() {
    bar(); // работает
    }
    bar(); // получим ReferenceError
</code></pre>

        <p>Здесь объект <code>bar</code> не доступен во внешней области, так как имя <code>bar</code> используется
            только для присвоения переменной <code>foo</code>; однако <code>bar</code> можно вызвать внутри функции.
            Такое поведение связано с особенностью работы JavaScript с <a href="#function.scopes">пространствами
                имен</a> - имя функции <em>всегда</em> доступно в локальной области видимости самой функции.</p></div>
</article>
    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #two -->
<div data-role="page" id="function.this" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">

     <article id=""><h2>Как работает <code>this</code></h2>

    <div><p>В JavaScript область ответственности специальной переменной <code>this</code> концептуально отличается от
        того, за что отвечает <code>this</code> в других языках программирования. Различают ровно <strong>пять</strong>
        вариантов того, к чему привязывается <code>this</code> в языке.</p>

    </div>
    <div><h3>1. Глобальная область видимости</h3>

<pre><code>this;
</code></pre>

        <p>Когда мы используем <code>this</code> в глобальной области, она будет просто ссылаться на <em>глобальный</em>
            объект.</p>

    </div>
    <div><h3>2. Вызов функции</h3>

<pre><code>foo();
</code></pre>

        <p>Тут <code>this</code> также ссылается на <em>глобальный</em> объект.</p>

        <aside class="es5"><p><strong>ES5 Замечание:</strong> В strict-режиме <strong>теряется</strong> понятие
            глобальности, поэтому в этом случае <code>this</code> будет иметь значение <code>undefined</code>.</p>
        </aside>

    </div>
    <div><h3>3. Вызов метода</h3>

<pre><code>test.foo();
</code></pre>

        <p>В данном примере <code>this</code> ссылается на <code>test</code>.</p>

    </div>
    <div><h3>4. Вызов конструктора</h3>

<pre><code>new foo();
</code></pre>

        <p>Если перед вызовом функции присутствует ключевое слово <code>new</code> то данная функция будет действовать
            как <a href="#function.constructors">конструктор</a>. Внутри такой функции <code>this</code> будет указывать
            на <em>новосозданный</em> <code>Object</code>.</p>

    </div>
    <div><h3>5. Переопределение <code>this</code></h3>

<pre><code>function foo(a, b, c) {}

    var bar = {};
    foo.apply(bar, [1, 2, 3]); // массив развернётся в a = 1, b = 2, c = 3
    foo.call(bar, 1, 2, 3); // аналогично
</code></pre>

        <p>Когда мы используем методы <code>call</code> или <code>apply</code> из <code>Function.prototype</code>, то
            внутри вызваемой функции <code>this</code> <strong>явным образом</strong> будет присвоено значение первого
            передаваемого параметра.</p>

        <p>Исходя из этого, в предыдущем примере (строка с <code>apply</code>) правило #3 <em>вызов метода</em> <strong>не</strong>
            будет применёно, и <code>this</code> внутри <code>foo</code> будет присвоено <code>bar</code>.</p>

        <aside>
            <p><strong>Замечание:</strong> <code>this</code> <strong>нельзя</strong> использовать внутри литералов
                <code>{}</code> (<code>Object</code>) для ссылки на сам объект. Т.е. если мы напишем <code>var obj =
                    {me: this}</code>, то <code>me</code> не будет ссылаться на <code>obj</code>, поскольку
                <code>this</code> присваивается только по одному из пяти описанных правил.</p>
        </aside>

    </div>
    <div><h3>Наиболее распространенные ошибки</h3>

        <p>Хотя большинство из примеров ниже наполнены глубоким смыслом, первый из них можно считать ещё одним упущением
            в самом языке, поскольку он <strong>вообще</strong> не имеет практического применения.</p>

<pre><code>Foo.method = function() {
    function test() {
    // this ссылается на глобальный объект
    }
    test();
    }
</code></pre>

        <p>Распространенным заблуждением будет то, что <code>this</code> внутри <code>test</code> ссылается на
            <code>Foo</code>, но это <strong>не так</strong>.</p>

        <p>Для того, чтобы получить доступ к <code>Foo</code> внутри функции <code>test</code>, необходимо создать
            локальную перменную внутри <code>method</code>, которая и будет ссылаться на <code>Foo</code>.</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
    // Здесь используем that вместо this
    }
    test();
    }
</code></pre>

        <p>Подходящее имя для переменной - <code>that</code>, его часто используют для ссылки на внешний
            <code>this</code>. В комбинации с <a href="#function.closures">замыканиями</a> <code>this</code> можно
            пробрасывать в глобальную область, или в любой другой объект.</p>

        <aside>
            <p><strong>Замечание</strong> от перев. Кроме <code>that</code> также часто встречаются <code>this_</code>,
                <code>self_</code> и другие варианты, но лучше принять для себя <code>that</code> как стандарт и тогда,
                возможно, все вокруг тоже будут им пользоваться.</p>
        </aside>

    </div>
    <div><h3>Назначение методов</h3>

        <p>Еще одной фичей, которая <strong>не</strong> работает в <code>JavaScript</code>, является создание
            псевдонимов для методов, т.е. <strong>присвоение</strong> метода объекта переменной.</p>

<pre><code>var test = someObject.methodTest;
    test();
</code></pre>

        <p>Следуя первому правилу <code>test</code> вызывается как обычная функция; следовательно <code>this</code>
            внутри него больше не ссылается на <code>someObject</code>.</p>

        <p>Хотя позднее связывание <code>this</code> на первый взгляд может показаться плохой идеей, но на самом деле
            именно благодаря этому работает <a href="#object.prototype">наследование прототипов</a>.</p>

<pre><code>function Foo() {}
    Foo.prototype.method = function() {};

    function Bar() {}
    Bar.prototype = Foo.prototype;

    new Bar().method();
</code></pre>

        <p>В момент, когда будет вызван <code>method</code> нового экземляра <code>Bar</code>, <code>this</code> будет
            ссылаться на этот самый экземпляр.</p></div>
</article>

    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->




<!-- Start of second page: #two -->
<div data-role="page" id="function.closures" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">

        <article >
            <h2>Замыкания и ссылки</h2>

    <div><p>Одним из самых мощных инструментов JavaScript&#39;а считаются возможность создавать <em>замыкания</em> — это
        такой приём, когда наша область видимости <strong>всегда</strong> имеет доступ к внешней области, в которой она
        была объявлена. Собственно, единственный механизм работы с областями видимости в JavaScript — это <a
                href="#function.scopes">функции</a>: т.о. объявляя функцию, вы автоматически реализуете замыкания.</p>

    </div>
    <div><h3>Эмуляция приватных свойств</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
    increment: function() {
    count++;
    },

    get: function() {
    return count;
    }
    }
    }

    var foo = Counter(4);
    foo.increment();
    foo.get(); // 5
</code></pre>

        <p>В данном примере <code>Counter</code> возвращает <strong>два</strong> замыкания: функции
            <code>increment</code> и <code>get</code>. Обе эти функции сохраняют <strong>ссылку</strong> на область
            видимости <code>Counter</code> и, соответственно, имеют доступ к переменной <code>count</code> из этой самой
            области.</p>

    </div>
    <div><h3>Как это работает</h3>

        <p>Поскольку в JavaScript нельзя присваивать или ссылаться на области видимости, заполучить <code>count</code>
            извне <strong>не</strong> представляется возможным. Единственным способом взаимодействовать с ним остается
            использование двух замыканий.</p>

<pre><code>var foo = new Counter(4);
    foo.hack = function() {
    count = 1337;
    };
</code></pre>

        <p>В приведенном примере мы <strong>не</strong> изменяем переменную <code>count</code> в области видимости
            <code>Counter</code>, т.к. <code>foo.hack</code> не объявлен в <strong>данной</strong> области. Вместо этого
            будет создана или перезаписана <em>глобальная</em> переменная <code>count</code>;</p>

    </div>
    <div><h3>Замыкания внутри циклов</h3>

        <p>Часто встречается ошибка, когда замыкания используют внутри циклов, передавая переменную индекса внутрь.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
    console.log(i);
    }, 1000);
    }
</code></pre>

        <p>Данный код <strong>не</strong> будет выводить числа с <code>0</code> до <code>9</code>, вместо этого число
            <code>10</code> будет выведено десять раз.</p>

        <p><em>Анонимная</em> функция сохраняет <strong>ссылку</strong> на <code>i</code> и когда будет вызвана функция
            <code>console.log</code>, цикл <code>for</code> уже закончит свою работу, а в <code>i</code> будет
            содержаться <code>10</code>.</p>

        <p>Для получения желаемого результата необходимо создать <strong>копию</strong> переменной <code>i</code>.</p>

    </div>
    <div><h3>Во избежание ошибок</h3>

        <p>Для того, чтобы скопировать значение индекса из цикла, лучше всего использовать <a href="#function.scopes">анонимную
            функцию</a> как обёртку.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
    setTimeout(function() {
    console.log(e);
    }, 1000);
    })(i);
    }
</code></pre>

        <p>Анонимная функция-обертка будет вызвана сразу же, и в качестве первого аргумента получит <code>i</code>,
            <strong>значение</strong> которой будет скопировано в параметр <code>e</code>.</p>

        <p>Анонимная функция, которая передается в <code>setTimeout</code>, теперь содержит ссылку на <code>e</code>,
            значение которой <strong>не</strong> изменяется циклом.</p>

        <p>Еще одним способом реализации является возврат функции из анонимной функции-обертки, поведение этого кода
            будет таким же, как и в коде из предыдущего примера.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
    return function() {
    console.log(e);
    }
    })(i), 1000)
    }
</code></pre>

        <aside>
            <p><strong>Замечание</strong> от перев. Переменную <code>e</code> можно тоже назвать <code>i</code>, если вы
                хотите: это не поменяет поведения кода — внутренняя переменная <code>i</code> всё так же будет <em>копией</em>
                внешней переменной</p>
        </aside>
    </div>
</article>

    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #two -->
<div data-role="page" id="function.arguments" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">
       <article id=""><h2>Объект <code>arguments</code></h2>

    <div><p>В области видимости любой функции в JavaScript есть доступ к специальной переменной <code>arguments</code>.
        Эта переменная содержит в себе список всех аргументов, переданных данной функции.</p>

        <aside>
            <p><strong>Замечание:</strong> В случае, если переменная <code>arguments</code> уже была объявлена в области
                видимости функции либо путём присвоения через выражение <code>var</code>, либо являясь формальным
                параметром, объект <code>arguments</code> не будет создан.</p>
        </aside>

        <p>Объект <code>arguments</code> <strong>не</strong> является наследником <code>Array</code>. Он, конечно же,
            очень похож на массив, и даже содержит свойство <code>length</code> — но он не наследует <code>Array.prototype</code>,
            а представляет собой <code>Object</code>.</p>

        <p>По этой причине, у объекта <code>arguments</code> <strong>отсутствуют</strong> стандартные методы массивов,
            такие как <code>push</code>, <code>pop</code> или <code>slice</code>. Хотя итерация с использованием
            обычного цикла <code>for</code> по агрументам работает вполне корректно, вам придётся конвертировать этот
            объект в настоящий массив типа <code>Array</code>, чтобы применять к нему стандартные методы массивов.</p>

    </div>
    <div><h3>Конвертация в массив</h3>

        <p>Указанный код вернёт новый массив типа <code>Array</code>, содержащий все элементы объекта
            <code>arguments</code>.</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

        <p>Эта конвертация занимает <strong>много времени</strong> и использовать её в критических частях кода <strong>не
            рекомендуется</strong>.</p>

    </div>
    <div><h3>Передача аргументов</h3>

        <p>Ниже представлен рекомендуемый способ передачи аргументов из одной функции в другую.</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
    }
    function bar(a, b, c) {
    // делаем здесь что-нибудь
    }
</code></pre>

        <p>Другой трюк — использовать и <code>call</code> и <code>apply</code> вместе, чтобы быстро создать несвязанную
            обёртку:</p>

<pre><code>function Foo() {}

    Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
    };

    // Создаём несвязанную версию "method"
    // Она принимает параметры: this, arg1, arg2...argN
    Foo.method = function() {

    // Результат: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);

    };
</code></pre>

    </div>
    <div><h3>Формальные аргументы и индексы аргументов</h3>

        <p>Объект <code>arguments</code> создаёт по <em>геттеру</em> и <em>сеттеру</em> и для всех своих свойств и для
            формальных параметров функции.</p>

        <p>В результате, изменение формального параметра также изменит значение соответствующего свойства объекта <code>arguments</code>
            и наоборот.</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
    }
    foo(1, 2, 3);
</code></pre>

    </div>
    <div><h3>Мифы и правда о производительности</h3>

        <p>Объект <code>arguments</code> создаётся во всех случаях, лишь за двумя исключениями — когда он переопределён
            внутри функции (по имени) или когда одним из её параметров является переменная с таким именем. Неважно,
            используется при этом сам объект или нет.</p>

        <p><em>Геттеры</em> и <em>сеттеры</em> создаются <strong>всегда</strong>; так что, их использование практически
            никак не влияет на производительность.</p>

        <aside class="es5"><p><strong>ES5 Замечание:</strong> Эти <em>геттеры</em> и <em>сеттеры</em> не создаются в
            strict-режиме.</p>
        </aside>

        <p>Однако, есть один момент, который может радикально понизить производительность современных движков
            JavaScript. Этот момент — использование <code>arguments.callee</code>.</p>

<pre><code>function foo() {
    arguments.callee; // сделать что-либо с этим объектом функции
    arguments.callee.caller; // и с вызвавшим его объектом функции
    }

    function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
    foo(); // При обычных условиях должна бы была быть развёрнута...
    }
    }
</code></pre>

        <p>В коде выше, функция <code>foo</code> не может <a href="http://en.wikipedia.org/wiki/Inlining">быть
            развёрнута</a> (а могла бы), потому что для корректной работы ей необходима ссылка и на себя и на вызвавший
            её объект. Это не только кладёт на лопатки механизм развёртывания, но и нарушает принцип инкапсуляции,
            поскольку функция становится зависима от конкретного контекста вызова.</p>

        <p><strong>Крайне не рекомендуется</strong> использовать <code>arguments.callee</code> или какое-либо из его
            свойств. <strong>Никогда</strong>.</p>

        <aside class="es5"><p><strong>ES5 Замечание:</strong> В strict-режиме использование
            <code>arguments.callee</code> породит <code>TypeError</code>, поскольку его использование принято
            устаревшим.</p>
        </aside>
    </div>
</article>

    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #two -->
<div data-role="page" id="function.constructors" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">
           <article id=""><h2>Конструктор</h2>

    <div><p>Создание конструкторов в JavaScript также отличается от большинства других языков. Любая функция, вызванная
        с использованием ключевого слова <code>new</code>, будет конструктором.</p>

        <p>Внутри конструктора (вызываемой функции) <code>this</code> будет указывать на новосозданный
            <code>Object</code>. <a href="#object.prototype">Прототипом</a> этого <strong>нового</strong> объекта будет
            <code>prototype</code> функции, которая была вызвана в качестве коструктора.</p>

        <p>Если вызываемая функция не имеет явного возврата посредством <code>return</code>, то вернётся
            <code>this</code> — этот новый объект.</p>

<pre><code>function Foo() {
    this.bla = 1;
    }

    Foo.prototype.test = function() {
    console.log(this.bla);
    };

    var test = new Foo();
</code></pre>

        <p>В этом примере <code>Foo</code> вызывается в виде конструктора, следовательно прототип созданного объекта
            будет привязан к <code>Foo.prototype</code>.</p>

        <p>В случае, когда функция в явном виде возвращает некое значение используя <code>return</code>, то в результате
            выполнения конструктора мы получим именно его, <strong>но только</strong> если возвращаемое значение
            представляет собой <code>Object</code>.</p>

<pre><code>function Bar() {
    return 2;
    }
    new Bar(); // новый объект

    function Test() {
    this.value = 2;

    return {
    foo: 1
    };
    }
    new Test(); // возвращённый объект
</code></pre>

        <p>Если же опустить ключевое слово <code>new</code>, то функция <strong>не</strong> будет возвращать никаких
            объектов.</p>

<pre><code>function Foo() {
    this.bla = 1; // устанавливается глобальному объекту
    }
    Foo(); // undefined
</code></pre>

        <p>Этот пример в некоторых случаях всё-таки может сработать: это связано с поведением <a
                href="#function.this"><code>this</code></a> в JavaScript — он будет восприниматься парсером как <em>глобальный
            объект</em>.</p>

    </div>
    <div><h3>Фабрики</h3>

        <p>Если хотите избавится от необходимости использования <code>new</code>, напишите конструктор, возвращающий
            значение посредством <code>return</code>.</p>

<pre><code>function Bar() {
    var value = 1;
    return {
    method: function() {
    return value;
    }
    }
    }
    Bar.prototype = {
    foo: function() {}
    };

    new Bar();
    Bar();
</code></pre>

        <p>В обоих случаях при вызове <code>Bar</code> мы получим один и тот же результат — новый объект со свойством
            <code>method</code> (спасибо <a href="#function.closures">замыканию</a> за это).</p>

        <p>Также следует заметить, что вызов <code>new Bar()</code> никак <strong>не</strong> связан с прототипом
            возвращаемого объекта. Хоть прототип и назначается всем новосозданным объектам, но <code>Bar</code> никогда
            не возвращает этот новый объект.</p>

        <p>В предыдущем примере нет функциональных отличий между вызовом конструктора с оператором <code>new</code> или
            без него.</p>

    </div>
    <div><h3>Создание объектов с использованием фабрик</h3>

        <p>Часто рекомендуют <strong>не</strong> использовать <code>new</code>, поскольку если вы его забудете, это
            может привести к ошибкам.</p>

        <p>Чтобы создать новый объект, лучше использовать фабрику и создать новый объект <em>внутри</em> этой фабрики.
        </p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
    this.value = value;
    }

    obj.getPrivate = function() {
    return private;
    }
    return obj;
    }
</code></pre>

        <p>Хотя данный пример и сработает, если вы забыли ключевое слово <code>new</code> и благодаря ему легче работать
            с <a href="#function.closures">приватными переменными</a>, у него есть несколько недостатков</p>

        <ol>
            <li>Он использует больше памяти, поскольку созданные объекты <strong>не</strong> хранят методы в прототипе и
                соответственно для каждого нового объекта создаётся копия каждого метода.
            </li>
            <li>Чтобы эмулировать наследование, фабрике нужно скопировать все методы из другого объекта или установить
                прототипом нового объекта старый.
            </li>
            <li>Разрыв цепочки прототипов просто по причине забытого ключевого слова <code>new</code> идёт в разрез с
                духом языка.
            </li>
        </ol>

    </div>
    <div><h3>Заключение</h3>

        <p>Хотя забытое ключевое слово <code>new</code> и может привести к багам, это точно <strong>не</strong> причина
            отказываться от использования прототипов. В конце концов, полезнее решить какой из способов лучше совпадает
            с требованиями приложения: очень важно выбрать один из стилей создания объектов и после этого <strong>не
                изменять</strong> ему.</p></div>
</article>

    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->


<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->
<!-- Start of second page: #two -->
<div data-role="page" id="object.general" data-theme="a">

    <div data-role="header" data-theme="a">
        <h1>js Garden tips </h1>
        <a href="#one" data-icon="home" data-iconpos="notext" data-direction="reverse" class="ui-btn-right jqm-home">Home</a>
    </div>
    <!-- /header -->
    <div data-role="content" data-theme="b">


    </div>
    <!-- /content -->

    <div data-role="footer">
        <h4>Page Footer</h4>
    </div>
    <!-- /footer -->
</div>
<!-- /page two -->

</body>
</html>